"""
Open3d visualization tool box
Written by Jihan YANG
All rights preserved from 2021 - present.

NOTES: This is a slightly modified version of open3d_vis_utils.py built specifically for viewing data generated outside of OpenPCDet.
       It is nearly identical with the exception of the change below.

	7/28/24: A slight modification was made by Mason Audet on 7/28/24 to draw_boxes (line appending conf scores as text to each box).
       		 I removed the '.item()' from 'score[i]'. This was done to allow for the visualization of custom data generated by our 
       		 model-fusion approach to run properly. Our input is an array instead of a dictionary.
       			 
       			 
        08/01/24: Joong Ho Kim made some adjustments to view the visual windows in a fast sequence by setting a timer to close the window automaticcaly after a short period.
                  Also, adjusted the 'bbox' values to fit the exact region for capturing screenshot.



       file location should be: /home/<USER>/OpenPCDet/tools/visual_utils

"""

import open3d
import open3d as o3d
import open3d.visualization.gui as gui
import open3d.visualization.rendering as rendering
import torch
import matplotlib
import numpy as np
from PIL import ImageGrab
import time
import pyautogui
import threading

box_colormap = [
    [1, 1, 1],
    [0, 1, 0],
    [0, 1, 1],
    [1, 1, 0],
]


def get_coor_colors(obj_labels):
    """
    Args:
        obj_labels: 1 is ground, labels > 1 indicates different instance cluster

    Returns:
        rgb: [N, 3]. color for each point.
    """
    colors = matplotlib.colors.XKCD_COLORS.values()
    max_color_num = obj_labels.max()

    color_list = list(colors)[:max_color_num+1]
    colors_rgba = [matplotlib.colors.to_rgba_array(color) for color in color_list]
    label_rgba = np.array(colors_rgba)[obj_labels]
    label_rgba = label_rgba.squeeze()[:, :3]

    return label_rgba

# Setting a timer to close the window automatically after a short period
def close_window(window, delay=0.1):
    def close():
        time.sleep(delay)
        window.close()
    threading.Thread(target=close).start()



def draw_scenes(points, gt_boxes=None, ref_boxes=None, ref_labels=None, ref_scores=None, point_colors=None, draw_origin=True, iteration=None):
    if isinstance(points, torch.Tensor):
        points = points.cpu().numpy()
    if isinstance(gt_boxes, torch.Tensor):
        gt_boxes = gt_boxes.cpu().numpy()
    if isinstance(ref_boxes, torch.Tensor):
        ref_boxes = ref_boxes.cpu().numpy()

    app = gui.Application.instance
    app.initialize()
    
    window = gui.Application.instance.create_window('Visuals', 1280, 720)
    scene = gui.SceneWidget()
    
    window.add_child(scene)
    
    scene.scene = rendering.Open3DScene(window.renderer)
    scene.scene.set_background([0, 0, 0, 1])
    
    # draw origin
    if draw_origin:
        axis_pcd = open3d.geometry.TriangleMesh.create_coordinate_frame(size=1.0, origin=[0, 0, 0])
        scene.scene.add_geometry('origin', axis_pcd, rendering.MaterialRecord())

    pts = open3d.geometry.PointCloud()
    pts.points = open3d.utility.Vector3dVector(points[:, :3])

    scene.scene.add_geometry('points', pts, rendering.MaterialRecord())
    
    
    
    if point_colors is None:
        pts.colors = open3d.utility.Vector3dVector(np.ones((points.shape[0], 3)))
    else:
        pts.colors = open3d.utility.Vector3dVector(point_colors)

    if gt_boxes is not None:
        vis = draw_box(vis, gt_boxes, (0, 0, 1))
        scene.scene = draw_box(scene, gt_boxes, (0, 0, 1))

    if ref_boxes is not None:
        scene.scene = draw_box(scene, ref_boxes, (0, 1, 0), ref_labels, ref_scores)
        
    bounds = scene.scene.bounding_box
    scene.setup_camera(60, bounds, bounds.get_center())
    
    
    center = [10,0,0] #10,0,0
    eye = [-15,-1,10] #-100,-1,100 
    up = [0,0,100] #0,0,100
    
    scene.look_at(center, eye, up)
    
    
    
    def on_layout(event):
        r = window.content_rect
        scene.frame = r
    window.set_on_layout(on_layout)
    
    close_window(window, delay=0.1)
    
    app.run()
    
    iteration = iteration[:-4]
    
    # Capture the entire screen
    #screenshot = ImageGrab.grab()
    screenshot = ImageGrab.grab(bbox=(1280, 440, 2560, 1160))
    
    
    # Save the screenshot to a file
    screenshot.save(iteration + '.png')
    
    # Close the screenshot
    screenshot.close()
    

def translate_boxes_to_open3d_instance(gt_boxes):
    """
             4-------- 6
           /|         /|
          5 -------- 3 .
          | |        | |
          . 7 -------- 1
          |/         |/
          2 -------- 0
    """
    center = gt_boxes[0:3]
    lwh = gt_boxes[3:6]
    axis_angles = np.array([0, 0, gt_boxes[6] + 1e-10])
    rot = open3d.geometry.get_rotation_matrix_from_axis_angle(axis_angles)
    box3d = open3d.geometry.OrientedBoundingBox(center, rot, lwh)

    line_set = open3d.geometry.LineSet.create_from_oriented_bounding_box(box3d)

    lines = np.asarray(line_set.lines)
    lines = np.concatenate([lines, np.array([[1, 4], [7, 6]])], axis=0)

    line_set.lines = open3d.utility.Vector2iVector(lines)

    return line_set, box3d

def draw_box(scene, gt_boxes, color=(0, 1, 0), ref_labels=None, score=None):
    material = rendering.MaterialRecord()
    material.shader = 'unlitLine'
    material.line_width = 1
    for i in range(gt_boxes.shape[0]):
        line_set, box3d = translate_boxes_to_open3d_instance(gt_boxes[i])
        if ref_labels is None:
            line_set.paint_uniform_color(color)
        else:
            line_set.paint_uniform_color(box_colormap[ref_labels[i]])

        scene.scene.add_geometry('lines'+str(i), line_set, material)

        # Prints confidence score for each bounding box
        if score is not None:
            corners = box3d.get_box_points()
            coord = np.array(corners[5].reshape(3,1), dtype=np.float32)
            cur_score = str(round(score[i], 3))
            lab = scene.add_3d_label(coord, cur_score)	# Works with a pure string label
            lab.color = gui.Color(1.0, 0.0, 0.0)
            lab.scale = 1
    return scene.scene
